#!/bin/bash
# References:
# 1) https://stackoverflow.com/questions/7069682/how-to-get-arguments-with-flags-in-bash
# 2) https://pubs.opengroup.org/onlinepubs/9699919799/utilities/getopts.html

# Global variables
m_flag=''
h_flag=''
files=''

print_usage() {
  printf "Usage: ..."
	}

check_flags() {
while getopts 'mh' flag; do
# Note: If a character is followed by a colon (e.g. f:), that option is expected to have an argument
# If it does not provide an argument an error message will be shown
	case "${flag}" in
	h) h_flag='true' 
		print_usage
		exit 0;; # h_flag was specified
	m) m_flag='true' ;; # m_flag was specified
	*) print_usage # the case when an undefined flag is used
			 exit 1 ;; # print usage and exit with an error
	esac
done

echo "OPTIND= $OPTIND"
# OPTIND equals 2 if the -m option is specified, if no flag is specified then OPTIND equals 1
shift $(( OPTIND -1 ))


####v
# if unequal to zero, then flag was defined and exists
if [ ! -z "$m_flag" ]; then
	printf "Option -m specified. Multiple commits mode.\n"
fi

if [ ! -z "$h_flag" ]; then
	printf "Option -h specified. Display help/usage menu.\n"
fi
####^

# store all files listed (also no files possible)
files=$@

####v
printf "Files: "
for file in "$@"; do
	printf "%s " $file
done

# new line
printf "\n"

echo "files pruebilla: $files"
####^


return 0
}

check_files_are_listed() {
# check if $files string is greater than zero
if [ -n "$files" ]; then
	echo "YES" # there were files listed
else
	echo "NO" # no files were listed
fi

return 0
}

check_files_regular_exist(){

# reset values
local FILES_TO_CHECK=$@ # all inputs to this function will be checked
ALL_FILES_OK='YES' # variable to check if all files are appropriate
FILES_OK='' # variable to store files that exist
FILES_NOT_EXIST='' # variable to store files that don't exist


# check if the input to the function is not empty,
# if empty ALL_FILES_OK=NO -> return out of function

# check if $FILES_TO_CHECK string has a length of zero
if [ -z "$FILES_TO_CHECK" ]; then
	ALL_FILES_OK='NO'
	return 0 # end function, since no input
fi


# go through until no more positional parameters
while [[ $# -gt 0 ]]; do
	if [ -e "$1" ]; then # check if file exists
		if [ -f "$1" ]; then # check if file is a regular file
			FILES_OK=""$FILES_OK" $1" # append to FILES_OK
		else # file is not a regular file
		FILES_NOT_EXIST=""$FILES_NOT_EXIST" $1" # append to FILES_NOT_EXIST
		# at least one file is not regular
		ALL_FILES_OK='NO'
		fi
	else # file does not exist
		FILES_NOT_EXIST=""$FILES_NOT_EXIST" $1" # append to FILES_NOT_EXIST
		# at least one file does not exist
		ALL_FILES_OK='NO'
	fi
	# shift positional parameters
	shift
done

return 0

###v
echo "FILES OK: $FILES_OK"
echo "FILES NOT OK: $FILES_NOT_EXIST"
###^
}

ask_for_files() {
	read -p "Which files would you like to add to the commit? > "
	# Echo the keyboard input to be used as a variable later
	echo "$REPLY"
}

main(){
	# INPUT_MAIN can be either "YES" or "NO"
	local INPUT_MAIN=$1

	local FILES_TO_CHECK=$files

	if [ "$INPUT_MAIN" == "NO" ]; then
		# Use the output of ask_for_files as the variable for files to check
		# $(function) = run the function inside and use as output
		FILES_TO_CHECK="$(ask_for_files)"
	fi

	# Check if files exist and are regular files
	check_files_regular_exist $FILES_TO_CHECK

	# Check if all files are ok after check
	if [ "$ALL_FILES_OK" == "YES" ]; then
		# Add files to commit
		echo "You want to add the following files to your commit: $FILES_OK"
		#git add "$FILES_OK"
		#git status
		
		# Ask for a commit message
		read -p "Add a commit message: > "
		#git commit -m "$REPLY"
		echo "Commit message: $REPLY"
		#git push
		exit 0
	fi

}
# -----------------------------------------------------------------------------

# $@ expands into a list of all positional parameters, starting with 1, from the positional parameters 
# of the script being run
check_flags $@

# store the echo output of the function check_files_are_listed
# as a variable
LISTED_FILES="$(check_files_are_listed)"
INPUT_MAIN=$LISTED_FILES

# while loop for main program body
while true; do

	main $INPUT_MAIN

done


