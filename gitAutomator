#!/bin/bash
# References:
# 1) https://stackoverflow.com/questions/7069682/how-to-get-arguments-with-flags-in-bash
# 2) https://pubs.opengroup.org/onlinepubs/9699919799/utilities/getopts.html

# Global variables
m_flag=''
h_flag=''
files=''

print_usage() {
  printf "Usage: ..."
	}

check_flags() {
while getopts 'mh' flag; do
# Note: If a character is followed by a colon (e.g. f:), that option is expected to have an argument
# If it does not provide an argument an error message will be shown
	case "${flag}" in
	h) h_flag='true' 
		print_usage
		exit 0;; # h_flag was specified
	m) m_flag='true' ;; # m_flag was specified
	*) print_usage # the case when an undefined flag is used
			 exit 1 ;; # print usage and exit with an error
	esac
done

echo "OPTIND= $OPTIND"
# OPTIND equals 2 if the -m option is specified, if no flag is specified then OPTIND equals 1
shift $(( OPTIND -1 ))


####v
# if unequal to zero, then flag was defined and exists
if [ ! -z "$m_flag" ]; then
	printf "Option -m specified. Multiple commits mode.\n"
fi

if [ ! -z "$h_flag" ]; then
	printf "Option -h specified. Display help/usage menu.\n"
fi
####^

# store all files listed (also no files possible)
files=$@

####v
printf "Files: "
for file in "$@"; do
	printf "%s " $file
done

# new line
printf "\n"

echo "files pruebilla: $files"
####^


return 0
}

check_files_are_listed() {
# check if $files string is greater than zero
if [ -n "$files" ]; then
	echo "YES" # there were files listed
else
	echo "NO" # no files were listed
fi

return 0
}

check_files_regular_exist(){

# reset values
local FILES_TO_CHECK=$@ # all inputs to this function will be checked
ALL_FILES_OK='YES' # variable to check if all files are appropriate
FILES_OK='' # variable to store files that exist
FILES_NOT_EXIST='' # variable to store files that don't exist


# check if the input to the function is not empty,
# if empty ALL_FILES_OK=NO -> return out of function

# check if $FILES_TO_CHECK string has a length of zero
if [ -z "$FILES_TO_CHECK" ]; then
	ALL_FILES_OK='NO'
	return 0 # end function, since no input
fi


# go through until no more positional parameters
while [[ $# -gt 0 ]]; do
	if [ -e "$1" ]; then # check if file exists
		if [ -f "$1" ]; then # check if file is a regular file
			FILES_OK+="$1 " # append to FILES_OK, if file is regular and exists
		else # file is not a regular file
		FILES_NOT_EXIST+="$1 " # append to FILES_NOT_EXIST, if file is not regular
		# at least one file is not regular
		ALL_FILES_OK='NO'
		fi
	else # file does not exist
		FILES_NOT_EXIST+="$1 " # append to FILES_NOT_EXIST, if file does not exist
		# at least one file does not exist
		ALL_FILES_OK='NO'
	fi
	# shift positional parameters
	shift
done

return 0

###v
echo "FILES OK: $FILES_OK"
echo "FILES NOT OK: $FILES_NOT_EXIST"
###^
}

ask_for_files() {
	read -p "Which files would you like to add to the commit? > "
	# Echo the keyboard input to be used as a variable later
	echo "$REPLY"
}

main(){
	# INPUT_MAIN can be either "YES" or "NO"
	INPUT_MAIN=$1

	local FILES_TO_CHECK=$files
	
	#local UI_MORE_FILES=''

	if [ "$INPUT_MAIN" == "NO" ]; then
		# Use the output of ask_for_files as the variable for files to check
		# $(function) = run the function inside and use as output
		FILES_TO_CHECK="$(ask_for_files)"
	fi

	# Check if files exist and are regular files
	check_files_regular_exist $FILES_TO_CHECK

# ----------------------------------------------------------------
	# Check if all files are ok after check
	if [ "$ALL_FILES_OK" == "YES" ]; then
		# Add files to commit
		git add ${FILES_OK} && echo "The following files were added to your commit: $FILES_OK"

		#git status
		
	fi # ---- check if all files exist and are regular files "YES"
# ----------------------------------------------------------------

# some files used as input do not exist or are no regular files
	if [ "$ALL_FILES_OK" == "NO" ]; then
		# check if $FILES_OK is NOT empty/length is unequal to 0 (! -z)
		if [ ! -z  "$FILES_OK" ]; then
		# add the files that exist and are regular to the commit
			git add ${FILES_OK} && echo "The following files were added to your commit: $FILES_OK"

			read -p "Do you want to add more files to the commit? (y/n) > "
			# store the output of piping the echo of the reply to tr,
			# in order to use tr to translate all uppercase letters to lowercase letter
			# (if necessary)
			local UI_MORE_FILES="$(echo "$REPLY" | tr [:upper:] [:lower:])"

			# add more files to the commit
			if [ "$UI_MORE_FILES" == "y" ]; then
				ls -l # print all available files in the current folder
				INPUT_MAIN="NO" # input main is now NO, so that it starts the loop back by asking for more files
				return # exit the function main, in order to start the function back again from the beginning
			fi
			# the input wasn't either 'y' or 'n'
			# if the input was n it is going to jump to the line asking for a commit message anyways
			if [ "$UI_MORE_FILES" != "n" ]; then
						echo "Invalid input, proceeding to add commit message for the files added until now."
			fi
		fi # -- some files are OK

		# if NO files are OK
		if [ -z "$FILES_OK" ]; then
			echo "The files used as input were either non-existing or not regular files!"
			ls -l # print all available files in the current folder	
			INPUT_MAIN="NO" # input main is now NO, so that it starts the loop back by asking for more files
			return # exit the function main, in order to start the function back again from the beginning
		fi #-- NO files are OK

	fi # -- ALL_FILES_OK = NO
		
# ----------------------------------------------------------------


	# Ask for a commit message
	read -p "Add a commit message: > "
	# if commit is accepted, print the commit message
	git commit --quiet -m "$REPLY" && echo "Commit message: $REPLY"
	# if the m flag has zero length (not defined/false), then exit the program successfully, since no more commits are desired
	if [ -z "$m_flag" ]; then
		git push --quiet && echo "Commit(s) pushed successfully!"
		# By usign the -q flag or --quiet, git push suppresses all output, it could be interesting to use the stdout output (or stderr) of git push and git commit and git status to get more information and see if an error has occurred
		# only if the commits were successfully pushed then (&&) echo to stdout that the commits were pushed
		exit 0
	fi # -- NO m flag


}
# -----------------------------------------------------------------------------

# '$@' expands into a list of all positional parameters, starting with 1, from the positional parameters 
# of the script being run
check_flags $@

# store the echo output of the function check_files_are_listed
# as a variable
LISTED_FILES="$(check_files_are_listed)"
INPUT_MAIN=$LISTED_FILES

# while loop for main program body
while true; do

	main $INPUT_MAIN

done


